


<!DOCTYPE html>
<html>

<head>
<style>
body {
    background-color: white;
}
canvas {
    border:1px solid grey;
}
</style>
</head>

<body>
<p>Dragging ship drawings</p>
<p>Hit testing uses context.isPointInPath</p>


<button onclick="UpdateResults()">Click me</button>
<button onclick="check_properties()">Check properties</button>

<p id="demo"> Total Area </p>


<canvas id="canvas" width=500 height=300></canvas

 <div id='info'></div>


   <table id="myTable">
      <thead>
         <th> x </th>
         <th> y </th>
         <th> b </th>
		 <th> h </th>
      </thead>
      <tbody>
         <tr>

         </tr>

      </tbody>
   </table>

<button onclick="add_opening()">Add opening</button>

</body>

</html>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript">
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
ctx.strokeStyle = "lightgray";



var canvasOffset = $("#canvas").offset();
var offsetX = canvasOffset.left;
var offsetY = canvasOffset.top;

var mouseIsDown = false;
var lastX = 0;
var lastY = 0;

var ships = [];


var t_hout = 4.4 // thickness of the wood elements
var b_panel = 50 // width of the panel



// output for iterations
var txt = document.getElementById("demo");




function add_initial_opening(x,y, b,h, col, movable){

	makeShip(x, y, b, h, col, movable);
	addRow (x, y, b,h );
	drawAllShips();
}


function add_opening(){

	if (ships.length > 1){

		add_initial_opening( ships[ships.length - 1].x + ships[ships.length - 1].width+20,  ships[ships.length - 1].y, 80, 150, "ivory",true);
		//addRow (100, 50, 80, 150)
	} else {
		add_initial_opening(30, Math.round(0+Math.random()*100), 80, 150, "ivory",true);
	}
	UpdateResults();
}





function check_properties(){

//console.log("s0", ships[0].x,ships[0].y,ships[0].width,ships[0].height)
//console.log("s1", ships[1].x,ships[1].y,ships[1].width,ships[1].height)


ships[1].width = 120

///const canvas = document.getElementById("canvas");
//const ctx = canvas.getContext("2d");
//ctx.clearRect(0, 0, canvas.width, canvas.height);

ctx.fillStyle = "grey";
ctx.fillRect(0,0,150,75);


//drawAllShips();
}





function addRow(x,y,b,h) {
      // Get the table element in which you want to add row
      let table = document.getElementById("myTable");
   
      // Create a row using the inserRow() method and
      // specify the index where you want to add the row
      let row = table.insertRow(-1); // We are adding at the end
	  
      console.log("table len ", table.rows.length)
      
   
      // Create table cells
      let c1 = row.insertCell(0);
	  c1.setAttribute("contenteditable", "true");
	  c1.setAttribute("onkeyup", "update_obj("+ String(table.rows.length-3) + ")");
	  
	  
      let c2 = row.insertCell(1);
      c2.setAttribute("contenteditable", "true"); 
	  c2.setAttribute("onkeyup", "update_obj("+ String(table.rows.length-3) + ")");
	  
      let c3 = row.insertCell(2);
	  c3.setAttribute("contenteditable", "true"); 
	  c3.setAttribute("onkeyup", "update_obj("+ String(table.rows.length-3) + ")");
	  
	  let c4 = row.insertCell(3);
	  c4.setAttribute("contenteditable", "true"); 
	  c4.setAttribute("onkeyup", "update_obj("+ String(table.rows.length-3) + ")");
	  
// Create a cell for the "Delete" button
		if (ships.length >1) {
		  
		  let deleteCell = row.insertCell(4);
		  let deleteButton = document.createElement("button");
		  deleteButton.innerText = "Delete";
		  deleteButton.addEventListener("click", function () {
			deleteRow(row);
		  });
		  deleteCell.appendChild(deleteButton);
	  }

	
      // Add data to c1 and c2
      c1.innerText = x
      c2.innerText = y
      c3.innerText = b
	  c4.innerText = h
   }

  function deleteRow(row) {
    let table = document.getElementById("myTable");
    let rowIndex = row.rowIndex;
    table.deleteRow(rowIndex);
	
	console.log("ships len", ships.length, "deleted", rowIndex , ships[rowIndex-2].x )
    ships.splice(rowIndex-2, 1);  // does not work
	
	
	drawAllShips();
  }



	// changes the size or position of the opening by adjusting values in the table
    function changeOpeningSizeOrPosition(num) {

	
		var table = document.getElementById('myTable')

		// Access the second row (index 1) in the first column (index 0) in the tbody
		var tbody = table.getElementsByTagName("tbody")[0];
		var row = tbody.getElementsByTagName("tr")[num+1]; // Get the second row
		
        var x_t = row.getElementsByTagName("td")[0];
        var y_t = row.getElementsByTagName("td")[1];
        var width_t = row.getElementsByTagName("td")[2]; 
        var height_t = row.getElementsByTagName("td")[3]; 


        ships[num].x = parseInt(x_t.innerHTML); 
        ships[num].y = parseInt(y_t.innerHTML); 
        ships[num].width = parseInt(width_t.innerHTML);
        ships[num].height = parseInt(height_t.innerHTML);

		drawAllShips();
		UpdateResults();
		
    }

function updateTableAfterMove() {
    // Iterate through each ship and update its corresponding table row
   var table = document.getElementById("myTable");
    if (table && table.rows.length >= ships.length) {
        var tbody = table.getElementsByTagName("tbody")[0];

        for (var i = 0; i < ships.length; i++) {
            var ship = ships[i];
            var row = tbody.rows[i+1];
				
			row.cells[0].innerText = ship.x;
			row.cells[1].innerText = ship.y;
			row.cells[2].innerText = ship.width;
			row.cells[3].innerText = ship.height;
        }
    }
}




// make some ship

add_initial_opening(20, 30, 280, 200, "DarkSeaGreen", false)  // base
add_initial_opening(100, 50, 80, 150, "ivory",true)


function delay(callback, ms) {
  var timer = 0;
  return function() {
    var context = this, args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function () {
      callback.apply(context, args);
    }, ms || 0);
  };
}

$('#input').keyup(delay(function (e) {
  console.log('Time elapsed!', this.value);
}, 500));




function makeShip(x, y, width, height, fill, movable) {
    var ship = {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height,
        fill: fill,
		movable: movable
    }
    ships.push(ship);

    return (ship);
}


drawAllShips();


// ========================== DRAWING =============================

// drawing all objects in canvas
function drawAllShips() {


    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var i = 0; i < ships.length; i++) {
        var ship = ships[i]

        drawShip(ship);
		
		// adding vertical lines for each opening
		ctx.fillStyle = "DarkOrange";
		ctx.fillRect(ship.x-t_hout/2,  ships[0].y, t_hout*2, ships[0].height);
		ctx.fillRect(ship.x + ship.width - t_hout * 1.5 ,  ships[0].y, t_hout*2, ships[0].height);
		

		//draw_panel_connections();
		
		
		// filling the opening
		ctx.fillStyle = ship.fill;
		ctx.fill();
		ctx.stroke();
		
		ctx.strokeStyle = "DarkOrange";		//LightSalmon

		
		ctx.lineWidth = t_hout;
    }
}

function draw_panel_connections(){
		if ( ships.length >1  ){
		

			for (var i = 0; i < ships.length-1; i++) {
			
			
			
				if ( (ships[i+1].x  - (ships[i].x+ ships[i].width)  >  b_panel)     ){
					for (var i = 0; i < Math.floor( (ships[i+1].x  - (ships[i].x+ ships[i].width))/b_panel); i++)      {
						ctx.fillStyle = "DarkOrange";
						ctx.fillRect(ships[i].x+ ships[i].width + b_panel* (i+1),  ships[0].y, t_hout*2, ships[0].height);
					}
				}
			}
			
		
		}
		
		
}






// drawing each ship
function drawShip(ship) {

	  ctx.beginPath();
      ctx.moveTo(ship.x, ship.y);
      ctx.lineTo(ship.x + ship.width, ship.y);
      ctx.lineTo(ship.x + ship.width + 0, ship.y + ship.height / 2);
      ctx.lineTo(ship.x + ship.width, ship.y + ship.height);
      ctx.lineTo(ship.x, ship.y + ship.height);
      ctx.closePath();
	  
	  
}


// ========================== MOUSE MOVEMENT =============================


function handleMouseDown(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);

    // mousedown stuff here
    lastX = mouseX;
    lastY = mouseY;
    mouseIsDown = true;

}

function handleMouseUp(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);
	
	
    // mouseup stuff here
    mouseIsDown = false;
	//console.log("m up")
	
	updateTableAfterMove();
	UpdateResults();
	
}


function update_table_after_move(){



}



function handleMouseMove(e) {
    if (!mouseIsDown) {
        return;
    }

    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);
	

    // mousemove stuff here
    for (var i = 0; i < ships.length; i++) {
        var ship = ships[i];
        drawShip(ship);
        if (ctx.isPointInPath(lastX, lastY)) {
		
			if (i>0) {
			
			// restricting the movements of the squares inside the biggest one
			if (ship.x > ships[0].x) {ship.x += (mouseX - lastX)} else {ship.x  = ships[0].x+1}
			if (ship.y > ships[0].y) {ship.y += (mouseY - lastY)} else {ship.y  = ships[0].y+1}
			
			//if (ship.right < ships[0].right) {ship.x += (mouseX - lastX)} else {ship.x  = ships[0].right - ship.width -1}
			//if (ship.y > ships[0].y) {ship.y += (mouseY - lastY)} else {ship.y  = ships[0].y+1}
			
			
			//if (ship.right < ships[0].right) {ship.right = ship.x + ship.width} else {ship.right  = ships[0].right-1}
			//if (ship.bottom < ships[0].bottom) {ship.bottom = ship.x + ship.width} else {ship.bottom  = ships[0].bottom -1}
			
         
            ship.right = ship.x + ship.width;
            ship.bottom = ship.y + ship.height;
			}
        }
    }
    lastX = mouseX;
    lastY = mouseY;
	

    drawAllShips();
}




//function attached to button
function UpdateResults() {

   //document.getElementById("demo").innerHTML = overlappingArea(ships[0], ships[1])
   let result = overlappingArea(ships[0],ships[1]);
   

	var canvas = document.getElementById("canvas");
	const greenPixels = countPixelsByColor(canvas, "DarkSeaGreen");
	const orangePixels = countPixelsByColor(canvas, "DarkOrange");
	const edgeOpeningPixels = countPixelsByColor(canvas, "LightSalmon");
	const openingPixels = countPixelsByColor(canvas, "ivory");
	
	var total_pix = greenPixels + orangePixels+ edgeOpeningPixels
	
	
	
	 document.getElementById("demo").innerHTML = "gr: " + greenPixels + " or: " + orangePixels + " edge: " + edgeOpeningPixels +  " op: " + openingPixels +
        " Sandwich: " + (greenPixels/total_pix).toFixed(2) + " Timber Frame: " + (orangePixels/total_pix).toFixed(2)  + " Outside calc: " + ((openingPixels)/total_pix).toFixed(2);

	// greenPixels
	
	console.log("Number of x pixels:", greenPixels);
	
	
	
	
	

}


// calculating the overlapping between two objects
function overlappingArea(first,second )
{

	let A1 = first.width * first.height
	let A2 = second.width * second.height
	
	let A1_perimeter = (first.width + first.height)*2 // offset hout
	let A2_perimeter = (second.width + second.height)*2 // offset hout
	

	let intersecting_area  = 
	Math.max(0, Math.min(second.right, first.right) - 
	Math.max(second.x, first.x)) * 
	Math.max(0, Math.min(second.bottom, first.bottom) - 
	Math.max(second.y, first.y))

	let percent_coverage = intersecting_area/A2
	
	// timber frame area
	let A_hout = A1_perimeter * t_hout + A2_perimeter * t_hout* (intersecting_area/A2)
	
	// totl wall area without windows
 	let total = A1- intersecting_area
	
	let  percentage = A_hout/total
	
	

	//console.log(A1, A2, intersecting_area, percent_coverage)
    return ( "Total: " + A1 + " Sandwich: " +  total + " A_hout: " + A_hout + " percentage: "  + percentage.toFixed(4))
}
 



// Function to count pixels with a specified color
function countPixelsByColor(canvas, colorName) {
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Convert color name to RGB values
    const color = getColorValues(colorName);

    let pixelCount = 0;

    // Loop through each pixel
    for (let i = 0; i < data.length; i += 4) {
        // Check if the pixel matches the specified color
        if (
            data[i] === color.red &&
            data[i + 1] === color.green &&
            data[i + 2] === color.blue
        ) {
            pixelCount++;
        }
    }

    return pixelCount;
}

// Helper function to get RGB values from color name
function getColorValues(colorName) {
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = tempCanvas.height = 1;
    const tempCtx = tempCanvas.getContext("2d");

    // Fill the canvas with the specified color
    tempCtx.fillStyle = colorName;
    tempCtx.fillRect(0, 0, 1, 1);

    // Get the RGB values from the canvas
    const pixelData = tempCtx.getImageData(0, 0, 1, 1).data;

    return {
        red: pixelData[0],
        green: pixelData[1],
        blue: pixelData[2],
    };
}





$("#canvas").mousedown(function (e) {
    handleMouseDown(e);
});
$("#canvas").mousemove(function (e) {
    handleMouseMove(e);
});
$("#canvas").mouseup(function (e) {
    handleMouseUp(e);
});



</script>
