
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Timber Volume</title>
    <style>
        body {
            background-color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            margin: 0;
        }

        canvas {
            border: 1px solid grey;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }

        table {
            width: 100%;
            max-width: 800px;
            margin-top: 20px;
            background-color: white;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        th, td {
            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #f8f9fa;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <p style="font-size: 25px;"><b>Simple timber volume</b></p>

    <div style="margin-bottom: 20px;">
        Panel width:
        <input type="number" id="panelWidthInput" value="1000" onchange="updateProjectProperties()">
    </div>

    <div style="margin-bottom: 20px;">
        Wood thickness:
        <input type="number" id="woodThicknessInput" value="44" onchange="updateProjectProperties()">
    </div>


    <p id="demo" style="font-size: 10px; color: gray;">Detailed results</p>
    <p id="main_rez"> - </p>

    <canvas id="canvas" width=600 height=400></canvas>

    <table id="myTable" class="table table-bordered">
        <thead class="thead-light">
            <th>x</th>
            <th>y</th>
            <th>b</th>
            <th>h</th>
        </thead>
        <tbody>
            <tr></tr>
        </tbody>
    </table>

    <button onclick="add_opening()">Add opening</button>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.1/dist/umd/popper.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">
  
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
ctx.strokeStyle = "lightgray";



var canvasOffset = $("#canvas").offset();
var offsetX = canvasOffset.left;
var offsetY = canvasOffset.top;

var mouseIsDown = false;
var lastX = 0;
var lastY = 0;

var ships = [];


var t_hout = 44 // thickness of the wood elements
var b_panel = 1000 // width of the panel

var txt = document.getElementById("demo");

var c = 0.1		// reduction cof to fit shape in canvas


ctx.translate(0, canvas.height);
ctx.scale(1, -1);


// show some elements 
updateProjectProperties(); 
launch_preconfigurated_element();


function launch_preconfigurated_element(){


// make some ship

add_shape(200, 300, 4000, 2700, "DarkSeaGreen", false);  // base
add_shape(660, 900, 800, 1500, "ivory",true);
add_shape(2000, 900, 800, 1500, "ivory",true);

}


function add_shape(x,y, b,h, col, movable){

	makeShip(x, y, b, h, col, movable);
	addRow (x, y, b,h );
	
	drawAllShips();
	draw_panel_connections();
	UpdateResults();
}


// adding new opening by button click
function add_opening(){

	if (ships.length > 1){

		add_shape( ships[ships.length - 1].x + ships[ships.length - 1].width+200,  
		ships[ships.length - 1].y, 800, 1500, "ivory",true);
		//addRow (100, 50, 80, 150)
	} else {
		add_shape(300, 400, 800, 1500, "ivory",true);
	}
	
}

function updateProjectProperties() {
    b_panel = parseInt(document.getElementById("panelWidthInput").value) || 0;
    t_hout = parseInt(document.getElementById("woodThicknessInput").value) || 0;
	
    drawAllShips();
    draw_panel_connections();
	UpdateResults();
}



function check_properties(){

//draw_panel_connections();
drawAllShips();

}

// add row in the table

function addRow(x,y,b,h) {
      // Get the table element in which you want to add row
      let table = document.getElementById("myTable");
   
      // Create a row using the inserRow() method and
      // specify the index where you want to add the row
      let row = table.insertRow(-1); // We are adding at the end
	  
      // Create table cells
      let c1 = row.insertCell(0);
	  c1.setAttribute("contenteditable", "true");
	  c1.setAttribute("onkeyup", "changeOpeningSizeOrPosition("+ String(table.rows.length-3) + ")");
	  
	  
      let c2 = row.insertCell(1);
      c2.setAttribute("contenteditable", "true"); 
	  c2.setAttribute("onkeyup", "changeOpeningSizeOrPosition("+ String(table.rows.length-3) + ")");
	  
      let c3 = row.insertCell(2);
	  c3.setAttribute("contenteditable", "true"); 
	  c3.setAttribute("onkeyup", "changeOpeningSizeOrPosition("+ String(table.rows.length-3) + ")");
	  
	  let c4 = row.insertCell(3);
	  c4.setAttribute("contenteditable", "true"); 
	  c4.setAttribute("onkeyup", "changeOpeningSizeOrPosition("+ String(table.rows.length-3) + ")");
	  
		// Create a cell for the "Delete" button
		if (ships.length >1) {
		  
		  let deleteCell = row.insertCell(4);
		  let deleteButton = document.createElement("button");
		  deleteButton.className = "btn btn-danger btn-sm"; 
		  
		  deleteButton.innerText = "Delete";
		  deleteButton.addEventListener("click", function () {
			deleteRow(row);
		  });
		  deleteCell.appendChild(deleteButton);
	  }

	
      // Add data to c1 and c2
      c1.innerText = x
      c2.innerText = y
      c3.innerText = b
	  c4.innerText = h
   }

  function deleteRow(row) {
    let table = document.getElementById("myTable");
    let rowIndex = row.rowIndex;
    table.deleteRow(rowIndex);
	

    ships.splice(rowIndex-2, 1);  
	
	
	drawAllShips();
	draw_panel_connections();
	UpdateResults();
  }



// changes the size or position of the opening by adjusting values in the table
function changeOpeningSizeOrPosition(num) {

	console.log("hiere", num)
	var table = document.getElementById('myTable')

	// Access the second row (index 1) in the first column (index 0) in the tbody
	var tbody = table.getElementsByTagName("tbody")[0];
	var row = tbody.getElementsByTagName("tr")[num+1]; // Get the second row
	
	var x_t = row.getElementsByTagName("td")[0];
	var y_t = row.getElementsByTagName("td")[1];
	var width_t = row.getElementsByTagName("td")[2]; 
	var height_t = row.getElementsByTagName("td")[3]; 


	ships[num].x = parseInt(x_t.innerHTML); 
	ships[num].y = parseInt(y_t.innerHTML); 
	ships[num].width = parseInt(width_t.innerHTML);
	ships[num].height = parseInt(height_t.innerHTML);

	// adjaust scake factor if does not fit in the canvas
	
	
	if ( (ships[num].width + ships[num].x)* c > 600 ){
	
		c = c* 	(5000/ (ships[num].width + ships[num].x) )
	}
	

	drawAllShips();
	draw_panel_connections();
	UpdateResults();
	

}

function updateTableAfterMove() {
    // Iterate through each ship and update its corresponding table row
   var table = document.getElementById("myTable");
    if (table && table.rows.length >= ships.length) {
        var tbody = table.getElementsByTagName("tbody")[0];

        for (var i = 0; i < ships.length; i++) {
            var ship = ships[i];
            var row = tbody.rows[i+1];
				
			row.cells[0].innerText = ship.x;
			row.cells[1].innerText = ship.y;
			row.cells[2].innerText = ship.width;
			row.cells[3].innerText = ship.height;
        }
    }
}



function delay(callback, ms) {
  var timer = 0;
  return function() {
    var context = this, args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function () {
      callback.apply(context, args);
    }, ms || 0);
  };
}

$('#input').keyup(delay(function (e) {
  console.log('Time elapsed!', this.value);
}, 500));




function makeShip(x, y, width, height, fill, movable) {
    var ship = {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height,
        fill: fill,
		movable: movable
    }
    ships.push(ship);

    return (ship);
}





// ========================== DRAWING =============================

// drawing all objects in canvas
function drawAllShips() {

	console.log("drawing alls ships", ships.length)
	
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var i = 0; i < ships.length; i++) {
        var ship = ships[i]

        drawShip(ship);
		
		// adding vertical lines for each opening
		ctx.fillStyle = "DarkOrange";
		ctx.fillRect(ship.x * c -(t_hout* c)/2,  ships[0].y* c, t_hout* c*2, ships[0].height* c);
		ctx.fillRect(ship.x * c + ship.width * c - t_hout * c * 1.5 ,  ships[0].y* c, t_hout*c * 2, ships[0].height* c);
		

		//draw_panel_connections();


		var edgeColor = "grey";
		

		
		// filling the opening
		ctx.fillStyle = ship.fill;
		ctx.fill();
		ctx.stroke();

		ctx.strokeStyle = edgeColor;		//LightSalmon  // DarkOrange
		ctx.lineWidth = t_hout *c;
		
		// adjusting needed - just a horizontal woodbord not included in calculation
		if (i == 0) {						
			ctx.fillStyle = "DarkOrange";

			ctx.fillRect(ship.x * c - t_hout*0.5*c ,  ships[0].y* c - t_hout*0.5*c, t_hout* c, ship.height * c + t_hout*c);
			
			ctx.fillRect(ship.x * c + ship.width * c - t_hout*0.5*c ,  ships[0].y* c - t_hout*0.5*c, t_hout* c, ship.height * c + t_hout*c);
			
			ctx.fillRect(ship.x * c - t_hout*0.5*c ,  ships[0].y* c + ships[0].height* c - t_hout*0.5*c, ship.width * c + t_hout*c,t_hout* c);
			
		} 
    }
}

// drawing each ship
function drawShip(ship) {
	
	ctx.beginPath();
      ctx.moveTo(ship.x* c, ship.y*c);
      ctx.lineTo(ship.x*c + ship.width*c, ship.y*c);
      ctx.lineTo(ship.x*c + ship.width*c + 0, ship.y*c + ship.height*c / 2);
      ctx.lineTo(ship.x*c + ship.width*c, ship.y*c + ship.height*c);
      ctx.lineTo(ship.x*c, ship.y*c + ship.height*c);
      ctx.closePath();
	  
}


// draw vertical connector bars if the distance between opening > panel width
function draw_panel_connections(){

		console.log("drawing panel connection")

		if ( ships.length >1  ){
		

			//iterating all opening to check a distance between them
			for (var i = 0; i < ships.length; i++) {
				var dist = 0;
				var connecting_bars = 0
			
				// distance between the edge and the 1st opening
				if (i==0){
					dist = ships[i+1].x  - ships[i].x - t_hout;
					connecting_bars = Math.floor(dist/b_panel)
					
					for (var e = 0; e < connecting_bars; e++)      {
						ctx.fillStyle = "DarkOrange";
						ctx.fillRect(ships[0].x * c + b_panel * (e+1) * c, 
						ships[0].y * c, t_hout*2 * c, ships[0].height * c);
					}
					
					
					
				}
				// distance after the last opening
				else if (i==ships.length-1){
					dist = (ships[0].x+ships[0].width)  - (ships[i].x+ ships[i].width) - t_hout;
					connecting_bars = Math.floor(dist/b_panel);
					
					for (var e = 0; e < connecting_bars; e++)      {
						ctx.fillStyle = "DarkOrange";
						ctx.fillRect(ships[i].x * c+ ships[i].width * c + b_panel * (e+1) * c, 
						ships[0].y * c, t_hout*2 * c, ships[0].height * c);
					}
					
					
				}// the rest
				else {
					dist = ships[i+1].x  - (ships[i].x+ ships[i].width)-t_hout;
					connecting_bars = Math.floor(dist/b_panel);
					
					for (var e = 0; e < connecting_bars; e++)      {
						ctx.fillStyle = "DarkOrange";
						ctx.fillRect(ships[i].x * c+ ships[i].width * c + b_panel * (e+1) * c, 
						ships[0].y * c, t_hout*2 * c, ships[0].height * c);
					}
				}
			}
			
		// if only one shape is available
		} else if (ships.length == 1) {
		
			connecting_bars = Math.floor((ships[0].width-t_hout)/b_panel);
			for (var e = 0; e < connecting_bars; e++)      {
				ctx.fillStyle = "DarkOrange";
				ctx.fillRect(ships[0].x * c + b_panel * (e+1) * c, 
				ships[0].y * c, t_hout*2 * c, ships[0].height * c);
			}
		}
		
}




// ========================== MOUSE MOVEMENT =============================


function handleMouseDown(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt((canvas.height - (e.clientY - offsetY)) / c);
	

    // mousedown stuff here
    lastX = mouseX;
    lastY = mouseY;
    mouseIsDown = true;

}

function handleMouseUp(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt((canvas.height - (e.clientY - offsetY)) / c);
	
	
    // mouseup stuff here
    mouseIsDown = false;
	//console.log("m up")
	
	draw_panel_connections();
	updateTableAfterMove();
	UpdateResults();
	
}


function update_table_after_move(){



}


function handleMouseMove(e) {
    if (!mouseIsDown) {
        return;
    }
	
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");

    mouseX = parseInt((e.clientX - offsetX)/c) ;
    //mouseY =  parseInt((e.clientY - offsetY)/c);
	mouseY = parseInt((canvas.height - (e.clientY - offsetY)) / c);

	

    // mousemove stuff here
    for (var i = 0; i < ships.length; i++) {
        var ship = ships[i];
        drawShip(ship);
        if (ctx.isPointInPath(lastX *c, lastY *c)) {
		
			if (i>0) {
			
			// restricting the movements of the squares inside the biggest one
			ship.x  += (mouseX - lastX)* 1;
			ship.y  += (mouseY - lastY)* 1;
			
            ship.right = ship.x + ship.width;
            ship.bottom = ship.y + ship.height;
			}
        }
    }
    lastX = mouseX;
    lastY = mouseY;
	
	


	ctx.beginPath();
	ctx.arc(mouseX, mouseY, 50, 0, 2 * Math.PI);
	ctx.fillStyle = "orange";
	ctx.fill();
	
    drawAllShips();
}







//function attached to button
function UpdateResults() {

 
   

	var canvas = document.getElementById("canvas");
	const greenPixels = countPixelsByColor(canvas, "DarkSeaGreen");
	const orangePixels = countPixelsByColor(canvas, "DarkOrange");
	const edgeOpeningPixels = countPixelsByColor(canvas, "LightSalmon");
	const openingPixels = countPixelsByColor(canvas, "ivory");
	
	var total_pix = greenPixels + orangePixels+ edgeOpeningPixels
	
	
	
	 document.getElementById("demo").innerHTML = "gr: " + greenPixels + " or: " + orangePixels + " edge: " + edgeOpeningPixels +  " op: " + openingPixels +
        " Sandwich: " + (greenPixels/total_pix).toFixed(2) + " Timber Frame: " + (orangePixels/total_pix).toFixed(2)  + " Outside calc: " + ((openingPixels)/total_pix).toFixed(2);

	// greenPixels
	
	 document.getElementById("main_rez").innerHTML = "Percentage: "+ ((orangePixels/total_pix)*100).toFixed(2) + " %"
	
}




// Function to count pixels with a specified color
function countPixelsByColor(canvas, colorName) {
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Convert color name to RGB values
    const color = getColorValues(colorName);

    let pixelCount = 0;

    // Loop through each pixel
    for (let i = 0; i < data.length; i += 4) {
        // Check if the pixel matches the specified color
        if (
            data[i] === color.red &&
            data[i + 1] === color.green &&
            data[i + 2] === color.blue
        ) {
            pixelCount++;
        }
    }

    return pixelCount;
}

// Helper function to get RGB values from color name
function getColorValues(colorName) {
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = tempCanvas.height = 1;
    const tempCtx = tempCanvas.getContext("2d");

    // Fill the canvas with the specified color
    tempCtx.fillStyle = colorName;
    tempCtx.fillRect(0, 0, 1, 1);

    // Get the RGB values from the canvas
    const pixelData = tempCtx.getImageData(0, 0, 1, 1).data;

    return {
        red: pixelData[0],
        green: pixelData[1],
        blue: pixelData[2],
    };
}





$("#canvas").mousedown(function (e) {
    handleMouseDown(e);
});
$("#canvas").mousemove(function (e) {
    handleMouseMove(e);
});
$("#canvas").mouseup(function (e) {
    handleMouseUp(e);
});



</script>
